# Generating attacks for sliding pieces

We could use precaclulated attack tables:

```
    U64 rook_attacks[64][4096];
    U64 bishop_attacks[64][512];
```

## How do we use these attack tables for rooks and what do they mean?

We think of every possibility the rook and the occupant pieces can be.
Let's say we index the table like this:
rook_attacks[rook_index][occupant_index]

    - rook_index shows us where the rook is positioned (one of the 64
        squares of the chess table
    - occupant_index is an index generated by the position of the occupant
        pieces that are in the rook's lines of attack

*The occupant pieces are all the pieces (white and black), excluding the
    attacking piece

Eg. (LERF square mapping):

Rook position:
    
```text
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0

```

Occupant pieces position (including white and black):

```text
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0
    1 0 0 0 0 1 1 1     -   The occupants bitboard
    0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0

```

As you can see, we only care about the pieces that are in the lines of
attack of our rook.

In our example, rook_index = 34.

occupant_index will be a number that is mapped to the squares marked by x:
```text
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0
    x x R x x x x x     -   14 squares used by the occupants
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0

```

The number of combinations the occupant table can be is 2^14,
0 <= occupant_index <= 2^14.

Let's say we somehow manage to map the occupants bitboard to the occupant
index. Then, rook_attacks[rook_index][occupant_index] will look like this:

```text
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0
    1 1 0 1 1 1 0 0     -   The attack candidates
    0 0 1 0 0 0 0 0
    0 0 1 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0

```


It can be showed that we don't actually care about the squares at the margins
in the occupants bitboard. So, in the worst case, we will have 12 squares
to consider (2^12).

```text
    0 0 0 0 0 0 0 0
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0
    0 x R x x x x 0      -   10 squares used by the occupants
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0
    0 0 0 0 0 0 0 0

```

Worst case, when the rook is in the corner:
```text
    0 0 0 0 0 0 0 0
    x 0 0 0 0 0 0 0
    x 0 0 0 0 0 0 0
    x 0 0 0 0 0 0 0      -   10 squares used by the occupants
    x 0 0 0 0 0 0 0
    x 0 0 0 0 0 0 0
    x 0 0 0 0 0 0 0
    R x x x x x x 0

```


## How do we map the occupants bitboard to the occupants_index?

That's where magics come into play.

Let's mark the occupant squares like this:
```text
    0 0 0 0 0 0 0 0
    0 0 F 0 0 0 0 0
    0 0 G 0 0 0 0 0
    0 A 0 B C D E 0      -   the occupants bitboard (occBB)
    0 0 H 0 0 0 0 0
    0 0 I 0 0 0 0 0
    0 0 J 0 0 0 0 0
    0 0 0 0 0 0 0 0

```

We want a magic number such that:

    occBB * magic = occIndexable

Where occIndeable has all the occupant bits at the end:

```text
    H E D C B A G F
    ........... J I
    ...............
    .. garbage ....      -   occIndexable
    ...............
    ...............
    ...............
    ...............

```

Since these bits are next to each other:
    
    occ_index = occIndexable >> (64 - 12)

```text
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0      -   occIndexable
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    B A G F 0 0 0 0
    ....J I H E D C

```

Keep in mind that this is not the worst case. There could've been 12 occupancy
bits.

Generating the magics is another story.

## What I actually did?


I acually generated the horizontal and vertical attacks separatelly by only
using one magic that does this:

```text
    A 0 0 0 0 0 0 0                 H G F E D C A B
    B 0 0 0 0 0 0 0                 ...............
    C 0 0 0 0 0 0 0                 ...............
    D 0 0 0 0 0 0 0 * MAGICFAR8  =  ... garbage ...
    E 0 0 0 0 0 0 0                 ...............
    F 0 0 0 0 0 0 0                 ...............
    G 0 0 0 0 0 0 0                 ...............
    H 0 0 0 0 0 0 0                 ...............

```

MAGICFAR8 = a magic that maps File A to Rank 8

And used smaller attack tables:
```
    U64 firstRankAttacks[64][8];
    U64 firstFileAttacks[64][8];
```

Where the tables are indexed liked this:
    firstRankAttacks[occ_index][rook_index]
    firstFileAttacks[occ_index][rook_index]



Resources:

1. https://www.chessprogramming.org/Flipping_Mirroring_and_Rotating#Anti-Clockwise (copied some functions from here in src/utils.cpp)
2. http://pradu.us/old/Nov27_2008/Buzz/research/magic/Bitboards.pdf (That's how I learned how magic bitboards work)
3. https://github.com/maksimKorzh/chess_programming/blob/master/src/magics/magics.txt (A list of precalculated magics)

