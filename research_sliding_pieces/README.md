# Generating attacks for sliding pieces

We could use precaclulated attack tables:

```
    U64 rook_attacks[64][4096];
    U64 bishop_attacks[64][512];
```

## How do we use these attack tables for rooks and what do they mean?

We think of every possibility the rook and the occupant pieces can be.
Let's say we index the table like this:
rook_attacks[rook_index][occupant_index]

    - rook_index shows us where the rook is positioned (one of the 64
        squares of the chess table
    - occupant_index is an index generated by the position of the occupant
        pieces that are in the rook's lines of attack

*The occupant pieces are all the pieces (white and black), excluding the
    attacking piece

Eg. (LERF square mapping):

Rook position:
    
```text
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0

```

Occupant pieces position (including white and black):

```text
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0
    1 0 0 0 0 1 1 1     -   The occupants bitboard
    0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0

```

As you can see, we only care about the pieces that are in the lines of
attack of our rook.

In our example, rook_index = 34.

occupant_index will be a number that is mapped to the squares marked by x:
```text
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0
    x x R x x x x x     -   14 squares used by the occupants
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0

```

The number of combinations the occupant table can be is 2^14,
0 <= occupant_index <= 2^14.

Let's say we somehow manage to map the occupants bitboard to the occupant
index. Then, rook_attacks[rook_index][occupant_index] will look like this:

```text
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0
    1 1 0 1 1 1 0 0     -   The attack candidates
    0 0 1 0 0 0 0 0
    0 0 1 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0

```


It can be showed that we don't actually care about the squares at the margins
in the occupants bitboard. So, in the worst case, we will have 12 squares
to consider (2^12).

```text
    0 0 0 0 0 0 0 0
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0
    0 x R x x x x 0      -   10 squares used by the occupants
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0
    0 0 x 0 0 0 0 0
    0 0 0 0 0 0 0 0

```

Worst case, when the rook is in the corner:
```text
    0 0 0 0 0 0 0 0
    x 0 0 0 0 0 0 0
    x 0 0 0 0 0 0 0
    x 0 0 0 0 0 0 0      -   12 squares used by the occupants
    x 0 0 0 0 0 0 0
    x 0 0 0 0 0 0 0
    x 0 0 0 0 0 0 0
    R x x x x x x 0

```


## How do we map the occupants bitboard to the occupants_index?

That's where magics come into play.

Let's mark the occupant squares like this:
```text
    0 0 0 0 0 0 0 0
    0 0 F 0 0 0 0 0
    0 0 G 0 0 0 0 0
    0 A 0 B C D E 0      -   the occupants bitboard (occBB)
    0 0 H 0 0 0 0 0
    0 0 I 0 0 0 0 0
    0 0 J 0 0 0 0 0
    0 0 0 0 0 0 0 0

```

We want a magic number such that:

    occBB * magic = occIndexable

Where occIndeable has all the occupant bits at the end:

```text
    H E D C B A G F
    ........... J I
    ...............
    .. garbage ....      -   occIndexable
    ...............
    ...............
    ...............
    ...............

```

Since these bits are next to each other:
    
    occ_index = occIndexable >> (64 - 12)

```text
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0      -   occIndexable
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    B A G F 0 0 0 0
    ....J I H E D C

```

Keep in mind that this is not the worst case. There could've been 12 occupancy
bits.

Generating the magics is another story.

## What I actually did?


I acually generated the horizontal and vertical attacks separatelly by only
using one magic that does this:

```text
    A 0 0 0 0 0 0 0                 H G F E D C A B
    B 0 0 0 0 0 0 0                 ...............
    C 0 0 0 0 0 0 0                 ...............
    D 0 0 0 0 0 0 0 * MAGICFAR8  =  ... garbage ...
    E 0 0 0 0 0 0 0                 ...............
    F 0 0 0 0 0 0 0                 ...............
    G 0 0 0 0 0 0 0                 ...............
    H 0 0 0 0 0 0 0                 ...............

```

MAGICFAR8 = a magic that maps File A to Rank 8

And used smaller attack tables:
```
    U64 firstRankAttacks[64][8];
    U64 firstFileAttacks[64][8];
```

Where the tables are indexed liked this:
    firstRankAttacks[occ_index][rook_index]
    firstFileAttacks[occ_index][rook_index]


Let's do an example where the rook is marked with R, and the occupants are
marked with 1:

```text
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0
    1 0 R 0 0 1 1 1
    0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0

```

### Generating the rank attacks

We first compute the attacks for the horizontal line. We will shift the
bitboard by an amount such that the lines is moved to the first rank:
```text
    0 0 0 0 0 0 0 0               0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0               0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0               0 0 0 0 0 0 0 0
    1 0 R 0 0 1 1 1     >> 32  =  0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0               0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0               0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0               0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0               1 0 R 0 0 1 1 1

```

Now, we're playing 1D chess:
```text
    1 0 R 0 0 1 1 1
```
The rook can be in 8 positions, where the position is given by the file
of the rook. We will use this to index our rook. In our case:
    
    rook_index = rookFile = 2 (a number from 0 to 7)

The occ_index is given by those 8 occupant bits:

```text
    1 0 0 0 0 1 1 1
```

But, it can be shown that we don't need the first and the last ones. So we
shift by 1 and mask:

```text
    ( 1 0 0 0 0 1 1 1 & 1 1 1 1 1 1 1 0 ) >> 1  =  0 0 0 0 1 1 0 0
```

And we take into consideration only the first 6 bits: 
    000011 (MSB is to the right)

So, occ_index = 48.

In our case firstRankAttacks[48][2] will be:
```text
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    1 1 0 1 1 1 0 0

```

But these are the attacks for the first rank. To get the attacks for our
rank, we shift back to the left:

```text
    0 0 0 0 0 0 0 0             0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0             0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0             0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0     << 32 = 1 1 0 1 1 1 0 0 
    0 0 0 0 0 0 0 0             0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0             0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0             0 0 0 0 0 0 0 0
    1 1 0 1 1 1 0 0             0 0 0 0 0 0 0 0

```

### Generating the file attacks

To compute the attacks for the vertical line, we will first shift it to file A:

```text
    0 0 0 0 0 0 0 0            0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0            0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0            1 0 0 0 0 0 0 0
    0 0 R 0 0 0 0 0     >> 2 = R 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0            0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0            1 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0            0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0            1 0 0 0 0 0 0 0

```

And use our magic to map file A to rank 8:

```text
    0 0 0 0 0 0 0 0                 1 0 1 0 R 1 0 0
    0 0 0 0 0 0 0 0                 ...............
    1 0 0 0 0 0 0 0                 ...............
    R 0 0 0 0 0 0 0 * MAGICFAR8  =  ... garbage ...
    0 0 0 0 0 0 0 0                 ...............
    1 0 0 0 0 0 0 0                 ...............
    0 0 0 0 0 0 0 0                 ...............
    1 0 0 0 0 0 0 0                 ...............

```
Resources:

1. https://www.chessprogramming.org/Flipping_Mirroring_and_Rotating#Anti-Clockwise (copied some functions from here in src/utils.cpp)
2. http://pradu.us/old/Nov27_2008/Buzz/research/magic/Bitboards.pdf (That's how I learned how magic bitboards work)
3. https://github.com/maksimKorzh/chess_programming/blob/master/src/magics/magics.txt (A list of precalculated magics)

